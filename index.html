<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grade 1 Adventure</title>

    <!-- Tailwind (CDN) for the classes used in your JSX -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM (UMD) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" defer></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" defer></script>

    <!-- Babel so the browser can understand JSX directly -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" defer></script>

    <style>
      html, body { height: 100%; }
      body { margin: 0; background: #f0f9ff; }
      /* smooth pulse helper for background blobs (optional) */
      @keyframes pulse-soft { 0%,100%{opacity:.55} 50%{opacity:.7} }
      .animate-pulse { animation: pulse-soft 3s ease-in-out infinite; }
    </style>
  </head>
  <body>
    <div id="app" class="min-h-screen"></div>

    <script type="text/babel">
      // make React hooks available (since we removed the import line)
      const { useEffect, useMemo, useRef, useState } = React;

      /**
       * Grade 1 Adventure – an all-in-one mini-game for Math, Words, Reading, and Puzzles.
       * - Designed for ages ~6–7 (Grade 1–2)
       * - Positive reinforcement: points, stickers, confetti, unlockable badges
       * - Sounds: "ta-da/cheer" on correct; "level up" on badge unlock
       * - Play "Mix" or choose a single category; default round length is 10
       */

      // --- Utility helpers -------------------------------------------------------
      function rand(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      function shuffle(arr) {
        const a = [...arr];
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      const STICKERS = ["⭐️","🎉","🏆","🦄","🐯","🐸","🐻","🐠","🧸","🚀","🌈","🍭","🍎","🧠"];
      const COLORS = ["#F97316","#10B981","#60A5FA","#F59E0B","#EF4444","#8B5CF6"];

      // Unlockable badges based on streak (latest thresholds)
      const BADGE_RULES = [
        { threshold: 3, code: "Ronaldo", icon: "⚽️" },
        { threshold: 5, code: "CR7", icon: "⚽️🔥" },
        { threshold: 10, code: "GOAT Badge + Finger Painter", icon: "🐐🎨" },
      ];

      // **Milestone scoring bonuses** (applied ONCE when the streak hits the threshold)
      const MILESTONE_BONUSES = { 3: 20, 5: 30, 10: 50 };

      // Words suitable for Grade 1–2
      const SIGHT_WORDS = ["the","and","you","said","play","here","look","come","make","we","can","like","see","go","to","is","in","it","up","be"];
      const CVC_WORDS = ["cat","dog","sun","map","bed","pig","hen","fox","bug","hat","bat","cup","web","jam","leg","rod","rib","cap","log","fin"];

      const RHYME_PAIRS = {
        cat: ["hat","bat","mat"],
        dog: ["fog","log","hog"],
        sun: ["fun","bun","run"],
        bed: ["red","fed","sled"],
        pig: ["wig","fig","dig"],
        fox: ["box","socks","rocks"],
        hat: ["cat","bat","mat"],
        cup: ["pup","pup","sup"],
      };

      // Sentence -> picture matching
      const SENTENCE_PICS = [
        { sentence: "two stars", pic: "⭐️⭐️" },
        { sentence: "three fish", pic: "🐟🐟🐟" },
        { sentence: "a red apple", pic: "🍎" },
        { sentence: "sun and cloud", pic: "☀️☁️" },
        { sentence: "a cat", pic: "🐱" },
        { sentence: "two dogs", pic: "🐶🐶" },
        { sentence: "a rocket and a rainbow", pic: "🚀🌈" },
        { sentence: "three hearts", pic: "❤️❤️❤️" },
      ];

      // Simple shape/emoji patterns for puzzles
      const PATTERN_SETS = [
        { seq: ["🔵","🔺","🔵","🔺"], next: "🔵" }, // ABAB
        { seq: ["🟩","🟧","🟩","🟧"], next: "🟩" }, // ABAB
        { seq: ["⭐️","⭐️","🌙","⭐️","⭐️"], next: "🌙" }, // AABAA
        { seq: ["🍎","🍌","🍇","🍎","🍌"], next: "🍇" }, // ABCAB
      ];

      // --- Question Generators ---------------------------------------------------
      function genMath() {
        const op = Math.random() < 0.5 ? "+" : "-";
        let a, b, correct;
        if (op === "+") {
          const sum = rand(2, 100);
          a = rand(1, sum - 1);
          b = sum - a;
          correct = sum;
        } else {
          a = rand(2, 100);
          b = rand(1, a - 1);
          correct = a - b; // 1..99
        }
        const options = new Set([correct]);
        while (options.size < 4) {
          const n = correct + rand(-10, 10);
          if (n >= 1 && n <= 100) options.add(n);
        }
        const choices = shuffle([...options]);
        return {
          category: "Math",
          prompt: op === "+" ? `What is ${a} + ${b}?` : `What is ${a} − ${b}?`,
          choices,
          answerIndex: choices.indexOf(correct),
          explain: `Because ${a} ${op} ${b} = ${correct}.`,
          flair: "➕",
        };
      }

      function genWords() {
        const mode = shuffle(["sight","starts","rhyme"])[0];
        if (mode === "sight") {
          const target = SIGHT_WORDS[rand(0, SIGHT_WORDS.length - 1)];
          const pool = shuffle(SIGHT_WORDS).slice(0, 3);
          const choices = shuffle([...new Set([target, ...pool])]).slice(0, 4);
          if (!choices.includes(target)) choices[rand(0, 3)] = target;
          return {
            category: "Words",
            prompt: `Tap the word: “${target}”`,
            choices,
            answerIndex: choices.indexOf(target),
            explain: `Great reading! The word is “${target}”.`,
            flair: "📚",
          };
        }
        if (mode === "starts") {
          const letter = String.fromCharCode(97 + rand(0, 25));
          const pool = shuffle([...CVC_WORDS, ...SIGHT_WORDS]).slice(0, 10);
          const starting = pool.find((w) => w.startsWith(letter)) || "";
          const target = starting || CVC_WORDS.find((w) => w.startsWith(letter)) || "cat";
          const distractors = shuffle(pool.filter((w) => !w.startsWith(letter))).slice(0, 3);
          const choices = shuffle([target, ...distractors]).slice(0, 4);
          return {
            category: "Words",
            prompt: `Which word starts with “${letter}”?`,
            choices,
            answerIndex: choices.indexOf(target),
            explain: `“${target}” starts with ${letter}.`,
            flair: "🔤",
          };
        }
        // rhyme mode
        const base = shuffle(Object.keys(RHYME_PAIRS))[0];
        const rhymes = RHYME_PAIRS[base];
        const target = rhymes[rand(0, rhymes.length - 1)];
        const others = shuffle([...CVC_WORDS, ...SIGHT_WORDS].filter((w) => w !== target && !rhymes.includes(w))).slice(0, 3);
        const choices = shuffle([target, ...others]);
        return {
          category: "Words",
          prompt: `Which word rhymes with “${base}”?`,
          choices,
          answerIndex: choices.indexOf(target),
          explain: `“${target}” rhymes with “${base}”.`,
          flair: "🎵",
        };
      }

      function genReading() {
        const idx = rand(0, SENTENCE_PICS.length - 1);
        const correct = SENTENCE_PICS[idx];
        const distractors = shuffle(SENTENCE_PICS.filter((_, i) => i !== idx)).slice(0, 3);
        const options = shuffle([correct, ...distractors]);
        return {
          category: "Reading",
          prompt: `Which picture matches: “${correct.sentence}”?`,
          choices: options.map((o) => o.pic),
          answerIndex: options.findIndex((o) => o === correct),
          explain: `This picture shows ${correct.sentence}.`,
          flair: "🖼️",
        };
      }

      function genPuzzles() {
        const mode = shuffle(["pattern","compare","count-next"])[0];
        if (mode === "pattern") {
          const p = PATTERN_SETS[rand(0, PATTERN_SETS.length - 1)];
          const prompt = `${p.seq.join(" ")}  …  ?`;
          const decoys = shuffle(PATTERN_SETS.map((x) => x.next).filter((x) => x !== p.next)).slice(0, 3);
          const choices = shuffle([p.next, ...decoys]);
          return {
            category: "Puzzles",
            prompt: `What comes next in the pattern?\n${prompt}`,
            choices,
            answerIndex: choices.indexOf(p.next),
            explain: `The pattern repeats, so the next is ${p.next}.`,
            flair: "🧩",
          };
        }
        if (mode === "compare") {
          const nums = shuffle([rand(1, 100), rand(1, 100), rand(1, 100), rand(1, 100)]);
          const biggest = Math.max(...nums);
          return {
            category: "Puzzles",
            prompt: "Which number is the biggest?",
            choices: nums.map((n) => String(n)),
            answerIndex: nums.indexOf(biggest),
            explain: `${biggest} is the greatest number here.`,
            flair: "📈",
          };
        }
        // count-next: simple number sequence +1 within 1–100
        const start = rand(1, 20);
        const seq = [start, start + 1, start + 2, start + 3];
        const correct = start + 4;
        const decoys = new Set([correct]);
        while (decoys.size < 4) {
          const n = correct + rand(-2, 2);
          if (n >= 1 && n <= 100) decoys.add(n);
        }
        const choices = shuffle([...decoys]).map(String);
        return {
          category: "Puzzles",
          prompt: `What number comes next?  ${seq.join(" → ")} → ?`,
          choices,
          answerIndex: choices.indexOf(String(correct)),
          explain: `We are counting by 1s, so after ${start + 3} comes ${correct}.`,
          flair: "🔢",
        };
      }

      function makeQuestion(category) {
        switch (category) {
          case "Math": return genMath();
          case "Words": return genWords();
          case "Reading": return genReading();
          case "Puzzles": return genPuzzles();
          default: return [genMath, genWords, genReading, genPuzzles][rand(0, 3)]();
        }
      }

      // --- Confetti (simple, dependency-free) -----------------------------------
      function useConfetti() {
        const ref = useRef(null);
        const burst = () => {
          const host = ref.current;
          if (!host) return;
          for (let i = 0; i < 28; i++) {
            const piece = document.createElement("div");
            const size = rand(6, 10);
            piece.style.position = "absolute";
            piece.style.width = `${size}px`;
            piece.style.height = `${size}px`;
            piece.style.background = COLORS[rand(0, COLORS.length - 1)];
            piece.style.left = `${50 + rand(-10, 10)}%`;
            piece.style.top = `20%`;
            piece.style.opacity = "0.9";
            piece.style.transform = `rotate(${rand(0, 360)}deg)`;
            piece.style.borderRadius = `${rand(0, 1) ? 50 : 8}%`;
            piece.style.transition = `all ${0.9 + Math.random() * 0.4}s ease-out`;
            host.appendChild(piece);
            requestAnimationFrame(() => {
              piece.style.top = `${rand(70, 110)}%`;
              piece.style.left = `${rand(5, 95)}%`;
              piece.style.opacity = "0";
              piece.style.transform += ` translateY(${rand(50, 120)}px)`;
            });
            setTimeout(() => piece.remove(), 1400);
          }
        };
        return { ref, burst };
      }

      // --- Simple Sounds (Web Audio) --------------------------------------------
      function useSound() {
        const ctxRef = useRef(null);
        function getCtx() {
          if (ctxRef.current) return ctxRef.current;
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return null;
          ctxRef.current = new Ctx();
          return ctxRef.current;
        }
        function ensureRunning() {
          const ctx = getCtx();
          if (!ctx) return null;
          if (ctx.state === "suspended") { try { ctx.resume(); } catch (e) {} }
          return ctx;
        }
        function note({ freq, start = 0, duration = 0.18, type = "square", gain = 0.06 }) {
          const ctx = ensureRunning();
          if (!ctx) return;
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, ctx.currentTime + start);
          g.gain.setValueAtTime(0.0001, ctx.currentTime + start);
          g.gain.linearRampToValueAtTime(gain, ctx.currentTime + start + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + start + duration);
          osc.connect(g).connect(ctx.destination);
          osc.start(ctx.currentTime + start);
          osc.stop(ctx.currentTime + start + duration + 0.05);
        }
        function taDaCheer() {
          const base = 523.25, major3 = 659.25, fifth = 783.99;
          note({ freq: base, duration: 0.22, type: "square", gain: 0.08 });
          note({ freq: major3, duration: 0.22, type: "square", gain: 0.07 });
          note({ freq: fifth, duration: 0.22, type: "square", gain: 0.07 });
          setTimeout(() => note({ freq: 1046.5, duration: 0.18, type: "triangle", gain: 0.07 }), 160);
        }
        function levelUp() {
          const seq = [523.25, 659.25, 783.99, 987.77, 1174.66];
          seq.forEach((f, i) => note({ freq: f, start: i * 0.09, duration: 0.14, type: "triangle", gain: 0.06 }));
        }
        return { taDaCheer, levelUp };
      }

      // --- Main Component --------------------------------------------------------
      function GradeOneAdventure() {
        const [screen, setScreen] = useState("start"); // start | play | end
        const [mode, setMode] = useState("Mix"); // Mix | Math | Words | Reading | Puzzles
        const [rounds, setRounds] = useState(10);
        const [qIndex, setQIndex] = useState(0);
        const [score, setScore] = useState(0);
        const [streak, setStreak] = useState(0); // continuous over games
        const [stickers, setStickers] = useState([]);
        const [badges, setBadges] = useState([]); // array of {code, icon, when}
        const [awardedMilestones, setAwardedMilestones] = useState(new Set()); // Set<number>
        const [question, setQuestion] = useState(null);
        const [lastResult, setLastResult] = useState(null); // {type, earned, bonus?}
        const [badgePopup, setBadgePopup] = useState(null); // {code, icon}
        const { ref: confettiRef, burst } = useConfetti();
        const { taDaCheer, levelUp } = useSound();

        // Persist streak, badges, and awarded milestones
        useEffect(() => {
          const savedStreak = Number(localStorage.getItem("g1_streak") || 0);
          if (!Number.isNaN(savedStreak)) setStreak(savedStreak);
          const savedBadges = JSON.parse(localStorage.getItem("g1_badges") || "[]");
          if (Array.isArray(savedBadges)) setBadges(savedBadges);
          const savedAwards = JSON.parse(localStorage.getItem("g1_awards") || "[]");
          if (Array.isArray(savedAwards)) setAwardedMilestones(new Set(savedAwards));
        }, []);
        useEffect(() => { localStorage.setItem("g1_streak", String(streak)); }, [streak]);
        useEffect(() => { localStorage.setItem("g1_badges", JSON.stringify(badges)); }, [badges]);
        useEffect(() => { localStorage.setItem("g1_awards", JSON.stringify([...awardedMilestones])); }, [awardedMilestones]);

        const allCats = ["Math","Words","Reading","Puzzles"];
        const activeCategory = useMemo(
          () => (mode === "Mix" ? allCats[rand(0, allCats.length - 1)] : mode),
          [mode, qIndex]
        );

        useEffect(() => {
          if (screen === "play") { setQuestion(makeQuestion(activeCategory)); }
        }, [screen, qIndex, mode]);

        function maybeUnlockBadges(newStreak) {
          const owned = new Set(badges.map((b) => b.code));
          BADGE_RULES.forEach((rule) => {
            if (newStreak === rule.threshold && !owned.has(rule.code)) {
              const award = { code: rule.code, icon: rule.icon, when: newStreak };
              setBadges((arr) => [...arr, award]);
              setBadgePopup(award);
              levelUp();
            }
          });
        }

        function handleChoice(i) {
          if (!question) return;
          const correct = i === question.answerIndex;
          if (correct) {
            const base = 10; // per-question base points
            const newStreak = streak + 1;
            const bonus = MILESTONE_BONUSES[newStreak] && !awardedMilestones.has(newStreak)
              ? MILESTONE_BONUSES[newStreak] : 0;

            setScore((s) => s + base + bonus);
            setStreak(newStreak);
            if (bonus > 0) {
              setAwardedMilestones((prev) => {
                const next = new Set(prev);
                next.add(newStreak);
                return next;
              });
            }
            maybeUnlockBadges(newStreak);
            setStickers((arr) => [...arr, STICKERS[rand(0, STICKERS.length - 1)]]);
            setLastResult({ type: "correct", earned: base, bonus });
            taDaCheer();
            burst();
          } else {
            setStreak(0);
            setLastResult({ type: "wrong", earned: 0 });
          }
        }

        function nextQuestion() {
          const next = qIndex + 1;
          if (next >= rounds) {
            setScreen("end");
          } else {
            setQIndex(next);
            setLastResult(null);
          }
        }

        function resetAll() {
          setScreen("start");
          setMode("Mix");
          setRounds(10);
          setQIndex(0);
          setScore(0);
          setStickers([]);
          setQuestion(null);
          setLastResult(null);
        }

        return (
          <div className="min-h-screen w-full relative overflow-hidden" ref={confettiRef}>
            <GradientBg />
            <div className="relative z-10 max-w-3xl mx-auto p-4 sm:p-6">
              <Header score={score} streak={streak} mode={mode} screen={screen} badges={badges} />

              {screen === "start" && (
                <StartScreen
                  mode={mode} setMode={setMode}
                  rounds={rounds} setRounds={setRounds}
                  onStart={() => {
                    setScreen("play");
                    setQIndex(0);
                    setScore(0);
                    setStickers([]);
                    setLastResult(null);
                  }}
                />
              )}

              {screen === "play" && question && (
                <PlayScreen
                  question={question}
                  qIndex={qIndex}
                  rounds={rounds}
                  onChoose={handleChoice}
                  lastResult={lastResult}
                  onNext={nextQuestion}
                />
              )}

              {screen === "end" && (
                <EndScreen score={score} stickers={stickers} badges={badges} onPlayAgain={resetAll} />
              )}

              {badgePopup && (
                <BadgeModal badge={badgePopup} onClose={() => setBadgePopup(null)} />
              )}
            </div>
          </div>
        );
      }

      // --- UI Subcomponents ------------------------------------------------------
      function Header({ score, streak, mode, screen, badges }) {
        return (
          <div className="flex items-center justify-between gap-3 mb-4">
            <h1 className="text-2xl sm:text-3xl font-extrabold tracking-tight drop-shadow text-white">
              Grade 1 Adventure <span className="text-yellow-200">🎒</span>
            </h1>
            <div className="flex items-center gap-2">
              <Badge>{mode === "Mix" ? "Mix Mode" : mode}</Badge>
              <Badge>Score: {score}</Badge>
              {screen !== "start" && <Badge>Streak: {streak}🔥</Badge>}
              {badges?.length > 0 && (
                <span className="hidden sm:inline-flex items-center gap-1 px-3 py-1 rounded-full bg-white/30 text-white font-semibold text-sm border border-white/50 shadow">
                  {badges.map((b, i) => (
                    <span key={i} title={b.code}>{b.icon}</span>
                  ))}
                </span>
              )}
            </div>
          </div>
        );
      }

      function StartScreen({ mode, setMode, rounds, setRounds, onStart }) {
        const MODES = ["Mix", "Math", "Words", "Reading", "Puzzles"];
        return (
          <Card>
            <div className="flex flex-col gap-4">
              <p className="text-lg">
                Welcome! Let's make a fun practice day with quick games in <b>Math</b>, <b>Words</b>, <b>Reading</b>, and <b>Puzzles</b>.
              </p>
              <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                {MODES.map((label) => (
                  <button
                    key={label}
                    className={`col-span-1 px-4 py-3 rounded-2xl font-bold transition transform hover:scale-[1.02] shadow ${mode === label ? "bg-yellow-300 text-black" : "bg-white/90"}`}
                    onClick={() => setMode(label)}
                  >
                    {label === "Mix" ? "🎲 Mix" :
                     label === "Math" ? "➕ Math" :
                     label === "Words" ? "🔤 Words" :
                     label === "Reading" ? "📖 Reading" : "🧩 Puzzles"}
                  </button>
                ))}
              </div>

              <div className="flex items-center gap-3">
                <label className="font-semibold">Rounds:</label>
                <input
                  type="range" min={6} max={20} value={rounds}
                  onChange={(e) => setRounds(parseInt(e.target.value))}
                  className="w-full"
                />
                <Badge>{rounds}</Badge>
              </div>

              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                <button
                  onClick={onStart}
                  className="px-5 py-3 rounded-2xl font-extrabold text-xl bg-green-500 text-white shadow hover:shadow-lg hover:brightness-110"
                >
                  ▶ Start Playing
                </button>
                <details className="bg-white/70 rounded-2xl p-3">
                  <summary className="cursor-pointer font-semibold">Parent Tips</summary>
                  <ul className="list-disc ml-6 mt-2 text-sm">
                    <li>Choose <b>Mix</b> for variety, or a single subject for focused practice.</li>
                    <li>Scoring: +10 per correct. <b>Milestone bonuses</b> at streaks 3 (+20), 5 (+30), 10 (+50). Wrong answers end the streak only.</li>
                    <li>Celebrate wins—stickers, confetti, and unlockable badges appear for streaks 🥳</li>
                  </ul>
                </details>

                {/* Developer/Test utilities */}
                <details className="bg-white/70 rounded-2xl p-3">
                  <summary className="cursor-pointer font-semibold">Developer Self-Tests</summary>
                  <TestPanel />
                </details>
              </div>
            </div>
          </Card>
        );
      }

      function PlayScreen({ question, qIndex, rounds, onChoose, lastResult, onNext }) {
        return (
          <Card>
            <div className="flex flex-col gap-4">
              <Progress value={(qIndex / rounds) * 100} />

              <div className="text-center">
                <div className="text-5xl mb-2">{question.flair}</div>
                <div className="text-lg sm:text-xl font-bold whitespace-pre-line">
                  {question.prompt}
                </div>
              </div>

              <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                {question.choices.map((c, i) => (
                  <AnswerButton
                    key={i}
                    label={String(c)}
                    onClick={() => onChoose(i)}
                    disabled={!!lastResult}
                  />
                ))}
              </div>

              {lastResult && (
                <div
                  className={`rounded-2xl p-4 text-center font-semibold ${
                    lastResult.type === "correct"
                      ? "bg-green-100 text-green-800"
                      : "bg-orange-100 text-orange-800"
                  }`}
                >
                  {lastResult.type === "correct" ? "✅ Correct! " : "💡 Not quite. "}
                  {lastResult.type === "correct" && (
                    <div>
                      You earned <b>{lastResult.earned}</b> points!
                      {lastResult.bonus ? (
                        <div className="mt-1">🎉 Milestone bonus: <b>+{lastResult.bonus}</b>!</div>
                      ) : null}
                    </div>
                  )}
                  {lastResult.type !== "correct" && (
                    <div className="mt-1 text-sm">Streak reset. You'll get it next time!</div>
                  )}
                  <div className="mt-3">
                    <button
                      onClick={onNext}
                      className="px-4 py-2 rounded-xl bg-blue-600 text-white font-bold shadow hover:shadow-lg"
                    >
                      Next ➜
                    </button>
                  </div>
                </div>
              )}

              {!lastResult && (
                <div className="text-center text-sm text-black/70">
                  Choose an answer above 👆
                </div>
              )}

              <div className="text-center text-xs text-black/60">
                Question {qIndex + 1} of {rounds}
              </div>
            </div>
          </Card>
        );
      }

      function EndScreen({ score, stickers, badges, onPlayAgain }) {
        const praise =
          score >= 140 ? "Amazing Super Star!" :
          score >= 100 ? "Fantastic Work!" :
          score >= 60 ? "Great Job!" : "Nice Practice!";
        return (
          <Card>
            <div className="flex flex-col items-center gap-4 text-center">
              <div className="text-6xl">🏁</div>
              <div className="text-2xl font-extrabold">{praise}</div>
              <div className="text-lg">Your final score: <b>{score}</b></div>

              <div className="w-full">
                <div className="font-semibold mb-1">Your Sticker Sheet:</div>
                <div className="min-h-[64px] rounded-2xl bg-white/70 p-3 grid grid-cols-8 gap-2 text-2xl">
                  {stickers.length ? (
                    stickers.map((s, i) => <div key={i}>{s}</div>)
                  ) : (
                    <div className="col-span-8 text-sm text-black/60">
                      Earn stickers by getting answers correct!
                    </div>
                  )}
                </div>
              </div>

              <div className="w-full">
                <div className="font-semibold mb-1">Badges Unlocked:</div>
                <div className="min-h-[48px] rounded-2xl bg-white/70 p-3 flex flex-wrap gap-2 text-xl">
                  {badges?.length ? (
                    badges.map((b, i) => (
                      <span key={i} className="px-3 py-1 rounded-full bg-white shadow border font-bold">
                        {b.icon} {b.code}
                      </span>
                    ))
                  ) : (
                    <div className="text-sm text-black/60">Keep a streak going to unlock badges!</div>
                  )}
                </div>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={onPlayAgain}
                  className="px-5 py-3 rounded-2xl bg-green-500 text-white font-extrabold shadow hover:shadow-lg"
                >
                  Play Again
                </button>
              </div>
            </div>
          </Card>
        );
      }

      function BadgeModal({ badge, onClose }) {
        return (
          <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
            <div className="absolute inset-0 bg-black/50" onClick={onClose} />
            <div className="relative bg-white rounded-3xl shadow-2xl border w-full max-w-md p-6 text-center">
              <div className="text-4xl mb-2">{badge.icon}</div>
              <div className="text-2xl font-extrabold mb-1">Congratulations!</div>
              <div className="text-lg mb-3">You have won a new badge!</div>
              <div className="text-xl font-bold mb-4">{badge.code}</div>
              <button onClick={onClose} className="px-5 py-2 rounded-2xl bg-blue-600 text-white font-extrabold shadow">
                Yay!
              </button>
            </div>
          </div>
        );
      }

      function AnswerButton({ label, onClick, disabled }) {
        return (
          <button
            disabled={disabled}
            onClick={onClick}
            className={`px-4 py-4 rounded-2xl font-extrabold text-lg bg-white/95 hover:scale-[1.02] transition transform shadow ${disabled ? "opacity-70 cursor-not-allowed" : ""}`}
          >
            {label}
          </button>
        );
      }

      function Card({ children }) {
        return (
          <div className="bg-white/80 backdrop-blur rounded-3xl shadow-xl p-4 sm:p-6 border border-white/40">
            {children}
          </div>
        );
      }

      function Badge({ children }) {
        return (
          <span className="px-3 py-1 rounded-full bg-white/30 text-white font-semibold text-sm border border-white/50 shadow">
            {children}
          </span>
        );
      }

      function Progress({ value }) {
        return (
          <div className="w-full h-3 bg-white/50 rounded-full overflow-hidden border border-white/60">
            <div
              className="h-full bg-gradient-to-r from-yellow-300 to-green-400"
              style={{ width: `${Math.min(100, Math.max(0, value))}%` }}
            />
          </div>
        );
      }

      function GradientBg() {
        return (
          <div className="absolute inset-0 -z-10">
            <div className="absolute -top-32 -left-32 w-96 h-96 bg-pink-300 rounded-full blur-3xl opacity-60 animate-pulse" />
            <div className="absolute top-10 right-0 w-[36rem] h-[36rem] bg-blue-300 rounded-full blur-3xl opacity-60 animate-pulse" />
            <div className="absolute bottom-0 left-1/3 w-[30rem] h-[30rem] bg-green-300 rounded-full blur-3xl opacity-50 animate-pulse" />
            <div className="absolute inset-0 bg-gradient-to-br from-cyan-500 via-sky-500 to-indigo-500 mix-blend-multiply" />
          </div>
        );
      }

      // --- Lightweight Self-Tests -----------------------------------------------
      function TestPanel() {
        const [output, setOutput] = useState(null);
        const run = () => {
          const logs = [];
          let passed = 0;
          let failed = 0;
          function assert(cond, msg) {
            if (!cond) { failed++; logs.push(`❌ ${msg}`); }
            else { passed++; }
          }
          for (let i = 0; i < 20; i++) {
            const q = genMath();
            assert(q.category === "Math", "genMath category");
            assert(Array.isArray(q.choices) && q.choices.length === 4, "genMath has 4 choices");
            assert(q.answerIndex >= 0 && q.answerIndex < q.choices.length, "genMath answerIndex in range");
            const correct = q.choices[q.answerIndex];
            assert(correct >= 1 && correct <= 100, "genMath correct within 1–100");
          }
          for (let i = 0; i < 20; i++) {
            const q = genWords();
            assert(q.category === "Words", "genWords category");
            assert(Array.isArray(q.choices) && q.choices.length >= 2 && q.choices.length <= 4, "genWords choices 2–4");
            assert(q.answerIndex >= 0 && q.answerIndex < q.choices.length, "genWords answerIndex in range");
          }
          for (let i = 0; i < 20; i++) {
            const q = genReading();
            assert(q.category === "Reading", "genReading category");
            assert(Array.isArray(q.choices) && q.choices.length === 4, "genReading has 4 choices");
            assert(q.answerIndex >= 0 && q.answerIndex < q.choices.length, "genReading answerIndex in range");
          }
          for (let i = 0; i < 20; i++) {
            const q = genPuzzles();
            assert(q.category === "Puzzles", "genPuzzles category");
            assert(Array.isArray(q.choices) && q.choices.length === 4, "genPuzzles has 4 choices");
            assert(q.answerIndex >= 0 && q.answerIndex < q.choices.length, "genPuzzles answerIndex in range");
          }
          const thresholds = BADGE_RULES.map((b) => b.threshold).join(",");
          assert(thresholds === "3,5,10", "Badge thresholds are 3,5,10");
          assert(Object.keys(MILESTONE_BONUSES).join(",") === "3,5,10", "Milestone bonus keys are 3,5,10");
          const m = makeQuestion("Math");
          const w = makeQuestion("Words");
          const r = makeQuestion("Reading");
          const p = makeQuestion("Puzzles");
          assert(m.category === "Math", "makeQuestion(Math)");
          assert(w.category === "Words", "makeQuestion(Words)");
          assert(r.category === "Reading", "makeQuestion(Reading)");
          assert(p.category === "Puzzles", "makeQuestion(Puzzles)");
          setOutput({ passed, failed, logs });
        };
        return (
          <div className="text-sm">
            <button
              onClick={run}
              className="px-3 py-2 rounded-xl bg-blue-600 text-white font-bold shadow hover:shadow-lg"
            >
              Run Self-Tests
            </button>
            {output && (
              <div className="mt-2 p-2 rounded-xl bg-white/80 border">
                <div>
                  Passed: <b>{output.passed}</b> · Failed: <b className={output.failed ? "text-red-600" : "text-green-700"}>{output.failed}</b>
                </div>
                <ul className="mt-2 list-disc ml-5 max-h-40 overflow-auto">
                  {output.logs.map((l, i) => (<li key={i}>{l}</li>))}
                </ul>
                {!output.failed && <div className="mt-2">✅ All checks passed.</div>}
              </div>
            )}
          </div>
        );
      }

      // Mount the app
      const root = ReactDOM.createRoot(document.getElementById("app"));
      root.render(<GradeOneAdventure />);
    </script>
  </body>
</html>

